---
title: "Processed To Analysis Ready Data Manipulation for Human Datasets"
author: "Gavin Fortenberry and Amy Paguirigan"
date: "July 23rd 2019 - updated May 4th 2023"
output: 
  html_document: 
    toc: yes
---

This is a project done by a SHIP high school intern in 2018 demonstrating how to analyze RNA seq data with a simple design and written by someone new to using R.  Hope this helps! 

# Install and load software 

If you do not already have Tidyverse and DESeq2 installed, this code will perform the task for you. You may be asked the following questions:

* "Update all/some/none"? type a (for all) and hit Enter
* "Do you want to install from sources the package which needs compilation? (Yes/no/cancel)" hit Enter 

```{r eval=FALSE, message=FALSE, warning=TRUE, include=FALSE}
# install tools for data manipulation and plotting
install.packages("tidyverse")

# install tools for genomic analysis
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
BiocManager::install("DESeq2")
```

Note that you will need to *install* a package only once per computer, but you'll need to *load* the packages every time you reopen RStudio.


## Load Libraries
```{r Load Libraries, message=FALSE, warning=FALSE}
library(tidyverse)
library(DESeq2)
```

# Preparing Your Data

## Importing Metadata
In this repository, there is a folder called `ProjectData` that contains all of the processed RNA seq data run through the STAR.wdl workflow along with a project metadata file called  "../ProjectData/*.Metadata.csv".  The working directory of this project is the `Analysis` folder where this script lives and your results will be saved.  

Here we will read these files in to R and store them as data frames. 
```{r}

metadataFile <- list.files(path = paste0("../ProjectData"),
                           pattern = "*.Metadata.csv",
                           full.names = TRUE)
metaData <- read.csv(file = metadataFile, 
                          # this is the path and filename of the file to read in
                          header = T, 
                          # the file has a header row, so we want that to become the column names of the data frame
                          stringsAsFactors = F
                          # Advanced topics:  read about strings vs factors!!
                          )

```


## Using tidyverse functions to learn about a dataset
The "tidyverse" is a group of R packages that work together to form a handy language for manipulating datasets in R.  While it contains a wide array of functionalities, we are going to primarily focus here on the use of the `dplyr` package for manipulating data frames.  

### Get a feel for your metadata
First you must get a feeling for what the data actually contain.  Here are some starting points for you to explore our two data frames.  

```{r echo=TRUE}
# What are the names of our columns?
colnames(metaData)

### How many samples are in each of this study's groups? 
metaData %>% group_by(torok_storb2018) %>% summarize(numberOfSamples = n())
```


### What are possible confounding variables in our study?
```{r}
metaData %>% group_by(torok_storb2018, rin_range, extraction_type) %>% summarize(numberOfSamples = n())
```


For the Tork-Storb 2018 data, it seems that we do not have any known, possible confounding variables in the study!  

## Importing RNA Seq Data
Now we need to read in the processed results from our RNA sequencing data analysis.  In this example we are going to read in the files created by a bioinformatic workflow applied to the raw RNA sequencing results generated by the sequencer.  The raw data contain the individual sequences of the fragments of DNA that were created from the RNA and sequenced.  The workflow used `STAR` to align these reads to the human genome reference and then count how many of these reads were aligned to regions of the genome we consider part of individual genes.  Thus, the results of this bioinformatic process create a table of data for each of the biospecimens that contain a column with ENSEMBL transcript IDs, and a column of the number of reads that the tool counted in that particular gene.  

Each sample has data in a different subfolder in "../ProjectData/", but each file we want has "out.tab" on the end of the file name.  Here we are going to go find a list of those files, and then next read each of them into R and store them as a list of data frames.  After we name each data frame in this list, we will merge them all into one large data frame. We provide an example of saving this resulting counts table in the repo and reading it back in for convenience for your later work.  

Processed data are in "../ProjectData/" and then in subdirectories based on the project. 
```{r}
dataFiles <- list.files(path = paste0("../ProjectData"), # path to the data we want
                       recursive = TRUE, # we want to look inside any subdirectories
                       pattern = ".out.tab", # we only want files that end in .out.tab
                       full.names = TRUE)  # we want the full path so we can find them later!
dataName <- gsub("_.*$", "", gsub("../ProjectData/[^/]*/", "", dataFiles));dataName # extracting the dataset name from the filenames using some regex.  For more help on that, go here (or google regex in R!) https://hypebright.nl/index.php/en/2020/05/25/ultimate-cheatsheet-for-regex-in-r-2/


# this lapply will read in each of the files full of read count data as a separate data frame and make sure the column names are the same for all of them.  Then we'll name each data frame by the sample name and then reformat it into what DESeq will need. 
dataList <- lapply(dataFiles, function(x) {
  Y <- read.delim(file = x,
             header = FALSE, # If you have a header row you may want to turn this to true, and remove the "skip" param
             skip = 4, # there are additional headers in these files we want to skip - in ours there are 4 rows to skip but if your header is the first row, you can remove this param or set it to 0
             sep = "\t",
             stringsAsFactors = FALSE)
  Z <- Y[,1:2] # in this case we had unstranded data so only need first two columns of each of the data files
  colnames(Z) <- c("ENS.geneID", "counts")
  Z
})
names(dataList) <- dataName # naming each of the files by it's sample name

studyData <- purrr::map_dfr(dataList, cbind, .id = "omics_sample_name") # reformatting it based on the sample names, which in our dataset is in the column labeled "omics_sample_name"

studyCountsTable <- tidyr::spread(data = studyData, key = "omics_sample_name", value = "counts") # Final reformat to get the merged data into the right "shape"
```

Write this counts table to a file for future use.  
```{r eval=FALSE, include=FALSE}
write.csv(x = studyCountsTable,
          file = paste0("Results/studyCountsTable.csv"),
          quote = F,
          row.names = F)
```

Read in this counts table in the future.  
```{r eval=FALSE, include=FALSE}
studyCountsTable <- read.csv(file = paste0("Results/studyCountsTable.csv"),
                             header = T,
                             stringsAsFactors = F)
```


### Explore your RNA Seq data
How many genes are there?
```{r}
length(unique(studyCountsTable$ENS.geneID))
```

How many total read counts did we get for each sample?
```{r}
readCounts <- colSums(studyCountsTable[,-1]) # column sum for all except the first Gene column
hist(readCounts)
max(readCounts)
min(readCounts)
```


studyCountsTable is your data if you are interested in differential gene expression analysis!!  

### Annotate with Gene Names
We want to provide a gene name for each of our ENSEMBL gene IDs.  We've downloaded a version 97 human ENSEMBL annotation dataset for your use.  

```{r}
ens97annotation <- read.delim("ENS.v97-annotation.txt", 
                              header = T,
                              stringsAsFactors = F)
ens97convert <- ens97annotation %>% dplyr::select(Gene.stable.ID.version, Gene.name) %>% unique()
studyCountsTableGenes <- left_join(studyCountsTable, ens97convert, by = c("ENS.geneID" = "Gene.stable.ID.version"))
```


Moving forward with your analysis ready dataset, you need to use the ENSEMBLE IDs as the unique field and then you can use this annotation file to annotate after your analysis.  

## Creating Analysis Ready Data
Next you will need to create an analysis-ready dataset ready for analysis via DESeq2 in order to get differential gene expression results. 

### Create a counts Matrix

```{r}
countsMatrix <- as.matrix(studyCountsTable[,-1])
rownames(countsMatrix) <- studyCountsTable[,1]

ncol(countsMatrix)  # How many columns are there?  Should be one column for each sample.
nrow(countsMatrix) # How many rows are there?  Should be one row for each gene ID (about 22,000 for humans)

```
### Create a phenotype Matrix
Imports all data/columns except
```{r}
colorder <- colnames(studyCountsTable)[-1]

metaData <- metaData %>% arrange(match(omics_sample_name, colorder))
# this makes the order of the rows in your metadata data frame the same as your order of data in studycountstable

phenoMatrix <-  as.matrix(metaData); nrow(phenoMatrix) 
#Sets rownames of phenoMat to data from df_combined  column of molecular ID's
rownames(phenoMatrix) <- as.character(metaData$omics_sample_name)
```

### Create a `Summarized Experiment` Data set
A DESeqDataSet object must have an associated design formula. The design formula expresses the variables which will be used in modeling. The formula should be a tilde (~) followed by the variables with plus signs between them (it will be coerced into an formula if it is not already). The design can be changed later, however then all differential analysis steps should be repeated, as the design formula is used to estimate the dispersions and to estimate the log2 fold changes of the model.
```{r} 
dseqDataSet<- DESeqDataSetFromMatrix(countsMatrix, phenoMatrix, design = ~ torok_storb2018)

dseqDataSet$torok_storb2018 <- relevel(dseqDataSet$torok_storb2018, "normBM") # make the "control" level be "normBM"

dseqDataSet <- dseqDataSet[ rowSums(counts(dseqDataSet)) > 1, ] # filter out rows of gene counts of 1's and 0's that will not be useful data in the future
```


`dseqDataSet` is now your "analysis ready" dataset for the DESeq2 package. 

# Differential Gene Expression Analysis
Read more here:
https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html#differential-expression-analysis 

Gives results of of the differential expression analysis with the current design formula.

```{r}
dseqAnalysis  <- DESeq(dseqDataSet)
dseqDataResults<- results(dseqAnalysis)
head(dseqDataResults, n = 2)
```

## Save results as a csv file for use outside of R
```{r}
dfResults <- data.frame(dseqDataResults)
dfResults$ENS.geneID <- rownames(dfResults)
dfResults <- left_join(dfResults, ens97convert, by = c("ENS.geneID" = "Gene.stable.ID.version"))
dfResults <- dfResults %>% select(ENS.geneID, Gene.name, everything())
write.csv(dfResults, 
          file = "Results/differentialGeneExpressionResults.csv", 
          row.names = F, quote = F)
```

